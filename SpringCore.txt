---------------------------------------------
---------------------------------------------
Spring Core:-
---------------------------------------------
---------------------------------------------

Loosely Coupled vs Tightly Coupled

IoC Container
	- Bean Factory
	- Application Context

Java Bean, Spring Bean, POJO

AnnotatationConfigApplicationContext class

@Configuration
@Bean
getBean() Retrieving - by .class 

JAVA Records 
JAVA try-with-resource 

@Component
@ComponentScan

@Primary
@Qualifier

@Autowired  ( @Autowired+@Qualifier )
Dependency Injection
	- Fields Injection 
	- Setters Injection
	- Constructor Injection (Recommended)

@Lazy (Not Recommended)
Lazy vs Eager

@Scope
Scope of Bean
 	- Singleton (Preferred) (Default)
	- Prototype

@PostConstruct
@PreDestroy

Stereotype Annotation replacing @Components
	- @Service
	- @Controller
	- @Repository

Terminologies
	- Boilerplate Coding
	- REST API
	- Microservice



---------------------------------------------
---------------------------------------------
SpringBoot Basics:-
---------------------------------------------
---------------------------------------------

Auto Configuration

spring-boot-starter-web
spring-boot-starter-test
spring-boot-devtool
spring-boot-starter-data-jpa


application.properties
	- logging level
	- user profiles
	- @Value

@ConfigurationProperties

Deploying jar
	- maven clean install command to generate jar
	- java -jar <path-to-jar> to run the file

Actuator
	- /actuator mapping
	- include endpoints in application.porperties



---------------------------------------------
---------------------------------------------
Spring Database Connectivity:- https://medium.com/omarelgabrys-blog/spring-a-head-start-spring-data-access-part-6-4b57b30ccbd4
---------------------------------------------
---------------------------------------------

Spring JDBC
	- @Repository
	- @Autowired JdbcTemplate object
	- private preparedstatement query strings
	- methods in repository class to insert, delete and fetch row from table using jdbcTemplate object's update() and queryForObject()
	- RowMapping ( new BeanPropertyRowMapping<>( "any pojo class with same variables as in database".class ) )

	- CommandLineRunner Interface and @Autowired repository class
	- CommandLineRunner run() method implement repository class object methods by passing args in insert(), delete(), findById() etc.

Spring JPA
	- @Entity and @Entity(name = "table name to map with") if name of class is same as of table name use @Entity
	- @Id use it for mapping to primary key attribute 
	- @Column and @Column(name = "column name of table to map with") if name is same use @Column
		
	- new @Repository class 
	- @Transactional annotation is mandatory below @Repository because repository class is used for performing transactional operations on database

	- @Autowired ( @PersistenceContext recommended annotation for more specific ) EntityManager Object 
	- EntityManager object is somewhat similar to JdbcTempelate but different way to implement methods
	- In repository class we create different methods with specific args like insert(), delete(), find() etc.
	- lets assume we have @Entity Course object course
	- insert() => entityManager.merge(course)
	- findById() => returns Course object entityManager.find(Course.class, id)
	- deleteById() => First, Course temp = entityManager.find(Course.class, id) Second, entityManager.remove(temp)

	- CommandLineRunner Interface and @Autowired repository class
	- CommandLineRunner run() method implement repository class object methods by passing args in insert(), delete(), findById() etc.

Spring Data JPA
	- @Entity and @Entity(name = "table name to map with") if name of class is same as of table name use @Entity
	- @Id use it for mapping to primary key attribute 
	- @Column and @Column(name = "column name of table to map with") if name is same use @Column

	- We can use @GeneratedValue to specify the prmiary id to  generate value and increment it by default

	- In Spring Data Jpa, Entity is mapped with Table by default, which means table are created according to name of entity automatically

	- No need to create methods or autowiring EntityManager object in repository class
	- We create repository interface which extends JpaRepository e.g, public interface SomeRepository extends JpaRepository< Course, Long > { } 
		{here, Course is entity to map and Long is type of @Id attribute}
	
	- CommandLineRunner interface by autowiring interface Repository object
	- CommandLineRunner run() method implement repository interface autowired object using default methods inherited by JpaRepository
		e.g., to insert => repository.save( new Course(1, "C#") )
			to find => repository.findById(2L)
			to delete => repository.deleteById(1L)
		must pass id with specific type that is long by 1L int by 1 etc.
	
	- SpringDataJpa Custom Methods and @Query() annoation
		( https://javatute.com/jpa/how-to-write-custom-method-in-repository-in-spring-data-jpa/ )

	- Must use @Repository annotation when you define some custom method in interface
		
	- application.properties => spring.jpa.defer-datasource-initialization=true to create table by default

---------------------------------------------
---------------------------------------------
Spring MVC Project:- https://medium.com/omarelgabrys-blog/spring-a-head-start-spring-mvc-part-5-db6b7b195e51
---------------------------------------------
---------------------------------------------

spring-boot-starter-web
spring-boot-starter-test
spring-boot-starter-devtools

@Controller for creating a controller where all @RequestMapping is done
@ResponseBody if no view is provided

Using JSP as a view 
	- location of jsp ( /src/main/resources/META-INF/resources/WEB-INF/jsp/*.jsp )
	- VIEW RESOLVER in application.properties
	  spring.mvc.view.prefix=/WEB-INF/jsp/
	  spring.mvc.view.suffix=.jsp
	- JSP maven dependency tomcat-embed-jasper
	- No need @ResponseBody because we are generating http response using jsp 


@RequestParam is used for passing as a parameter in @RequestMapping method to perform some operation on it
	- e.g., public String getLogin(@RequestParam String name) {
		      System.out.println(name); //Not Recommended to use System.out use Logger instead
			return "login";	
		  } 
	- localhost:8080/login?name=WeKi will show login.jsp also on terminal logs it prints WeKi

ModelMap
	- We use ModelMap for forwarding these request parameters to our view so that jsp can use it
	- e.g., public String getLogin(@RequestParam String name, ModelMap model) {
		      model.put("name", name);
			return "login";	
		  } 
	- JSP will print Hello WeKi by using tag <p> Hi ${name} </p>

So We Understand That, Controller forward requests from view and redirect the response to view using Model

Logger and LoggerFactory of SLF4j package 
	- Logger logger = LoggerFactory.getLogger(getClass());
	- e.g., public String getLogin(@RequestParam String name) {
			logger.debug("print {} at debug level", name);
			logger.info("print {} at info level", name);
			logger.warn("print {} at warn level", name);
		      System.out.println(name); //Not Recommended to use System.out use Logger instead
			return "login";	
		  } 
	- printing using logger depends on logging.levl of org.springframework
	- we can change logging level our package using logging.level.<package-name>=<logging-level>
	- Developing => debug, Production=> info
	- SpringBoot provides spring-boot-starter-logging dependency comes under spring-boot-starter-web jar 
	- By Default SpringBoot uses SLF4j Logger

Model Architecture
	- Model 1 ( views only, views+multiple controllers )
	- Model 2 ( views + controllers and controllers managed by FrontController)

Spring MVC works on Model 2 where DispatcherServlet is used as FrontController

DispatcherServlet
	- Recieves HttpRequest
	- Process the HttpRequest
		- Identifies correct Controller Method using RequestMapping
		- Executes Controller Method which returns Model and View name
		- Identifies correct view using ViewResolver i.e., prefix and suffix
		- Executes View based on model
	- Returns HttpResponse

Static Initializer Block JAVA Tutorial

@SessionAttributes() is used to provide scope of HttpRequest attributes to controllers having this attribute that is name attribute generated from login page and we used it in welcome page.
After that scope of request is completed so to use this attribute in listTodos page we need to specify @SessionAttribute("name") to TodoController.
To use this attribute in more controllers we need to use this attribute at each controller

Some Important JSP and JSTL dependencies
	- org.apache.tomcat.embed:tomcat-embed-jasper:provided (provide browser to view jsp)
	- jakarta.servlet.jsp.jstl:jakarta.servlet.jsp.jstl-api (provide tagLibs)
	- org.eclipse.jetty:glassfish-jstl (provide browser its implementation)


BootStrap CSS Framework -

	- org.webjars:jquery
	- org.webjars:bootstrap

	- ADD proper stylesheet and javascript in jsp file
		- /webjars/bootstrap/5.2.3/css/bootstrap.min.css
		- /webjars/jquery/3.6.3/jquery.min.js
		- /webjars/bootstrap/5.2.3/js/bootstrap.min.js

	- container, table, btn, btn-success
	

When we have many RequestParams in form then using @RequestParams in method parameters so verbose to avoid difficulty and long coding we use concept of Compound Bean or Form Backing Object	

We can redirect a HttpRequest by returning jsp page by prefixing with redirect: => e.g., redirect:list-todos where list-todos is a request mapping for listTodos.jsp


Form Backing Object is implemented by 2 Way Binding aka Form Validation

	- Dependency spring-boot-starter-validation

	- We need to bind get method to form default values and then post method binds user inputs to spring bean
	
	- Binding GET Method
		@RequestMapping(value="#", method=RequestMethod.GET)
		public String showTodo(ModelMap model) {

			String username = (String)model.get("name");
			Todo todo = new Todo(0, username, "", LocalDate.now(), false);
			model.put("todo", todo);

			return "add-todo";
		}
		
		@RequestMapping(value="#", method=RequestMethod.POST)
		public String showTodo(ModelMap model, Todo todo) {

			String username = (String)model.get("name");
			Todo todo = new Todo(username, todo.getDescription(), todo.targetDate(), false);
			todoService.addTodo(todo);

			return "add-todo";
		}
	
	- We also need to use JSTL form for Applying these binding
		<form:form method="post" modelAttribute="todo">
			<form:input type="text" name="description" path="description"></form:input>
			<form:input type="text" path="id"></form:input>
			<form:input type="text" path="done"></form:input>
			<input type="submit">
		</form:form>
	- here path is connected to attribute because modelAttribute is bean which is same name of spring bean object
	- In GET binding, we put default values to input fields from spring bean object in form
	- In POST binding, we fetch values from input field in a spring bean object from form


We can validate values before binding it to bean by using @Valid and different validatation constraints annotation at Bean attributes
	-	@RequestMapping(value="#", method=RequestMethod.POST)
		public String showTodo(ModelMap model, @Valid Todo todo) {

			String username = (String)model.get("name");
			Todo todo = new Todo(username, todo.getDescription(), todo.targetDate(), false);
			todoService.addTodo(todo);

			return "add-todo";
		}


	- We can print any error message in jsp by using BindingResult class
		@RequestMapping(value="#", method=RequestMethod.POST)
		public String showTodo(ModelMap model, @Valid Todo todo, BindingResult result) {
			
			if(result.hasErrors()) {
				return "redirect:todo";
			}

			String username = (String)model.get("name");
			Todo todo = new Todo(username, todo.getDescription(), todo.targetDate(), false);
			todoService.addTodo(todo);

			return "add-todo";
		}
		

		To print error next to input dialog, we use form:errors tag
		
		<form:error path="description"></form:error>

		We apply css class on taglib by using cssClass="btn btn-warning"


	Now to validate any bean attribute we add different validation annotation
		- @Size @NotNull @Digit @Email etc. can be found under jakarta.validation.constraints package injected by starter-validation jar


	To print error message we need to pass message param in @Size(min=10, message="Enter atleast 10 Letters");



For Date entry from input field we can use bootstrap datepicker just paste js and css relative path from in jsp
	- org.webjars:bootstrap-datepicker dependency
	- /webjars/bootstrap-datepicker/1.9.0./css/bootstrap-datepicker.min.css
	  /webjars/bootstrap-datepicker/1.9.0/js/bootstrap-datepicker.min.js
	- we can add script for a custom id #targetDate 
		<script type="text/javascript">
			$('#targetDate').datepicker( {
				format: 'yyyy-mm-dd'	
			} );
		</script>
		
		in application.properties, we can format date by using format.date=yyyy-MM-dd
	
Use bootsrap to add navigation bar visit bootsrap navbar site


______________________________________________________________________________________________________________________________________________________________________

Spring Security ====>


Dependency - starter-security
It provides by default login page to url mapping "localhost:8080/" => "localhost:8080/login"
Default Username is user and password is generated on terminal 

also spring security framework provides /logout page by default

also we cannot access any url links without login 

We need to configure the custom user and password using @Configuration and @Beans class and methods 



How To Configure Spring Security User and Password :-

// InMemoryUserDetailsManager(UserDetails... userDetails)
// BCryptPasswordEncoder
// User.builder()
// User belongs to  org.springframework.security.core.userdetails.User
@Configuration
public class SpringSecurityConfiguration {

	@Bean
	public InMemoryUserDetailsManager createUserDetailsManager() {
		UserDetails userDetails1 = userDetails("weki", "root"); 
		UserDetails userDetails2 = userDetails("unknown", "root"); 
		return new InMemoryUserDetailsManager(userDetails1, userDetails2);	
	}
	
	private UserDetails userDetails(String username, String password) {
		UserDetails userDetails = User.builder().passwordEncoder( input -> passwordEncoder().encode(input) ).username(username).password(password).roles("USER", "ADMIN").build();
		return userDetails;
	}
	@Bean
	private PasswordEncoder passwordEncoder() {
		return new BCryptPasswordEncoder();
	}
}


To get the login username -
In Controller Bean,
we use SecurityContextHolder class and Authentication class
  i.e., Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
now authentication object has different methods to retrieve username password etc.
 i.e., String username = authentication.getName();


____________________________________________________________________________________________________________________________________________________-

Spring Security Framework => 
	- All Urls are protected can only be accessed if login is approved
	- A login form is shown if unauthorized access 

Spring security be default doesn't provide access to Frames it is disabled by default
Also CSRF crosssite request form are disabled too

We need to enable these to access /h2-console i.e., We need to configure security beans 

Overriding this method which provide by default some filter which are url and csrf authorisation
HttpSecurity allow us to configure web based security

When we override the SecurityFilterChain we need to define entire chain again

@Bean SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
	http.authorizeHttpRequests( auth -> auth.anyRequest().authenticated() );
	
	http.formLogin( withDefaults() ); //withDefaults() static imported => import static org.springframework.security.config.Customizer.withDefaults;
	

	http.csrf().disable(); //disable csrf
	http.headers().frameOptions().disable(); //Enables Frames

	return http.build();	
}


__________________________________________________________________________________________________________________________________________________




Spring Boot Basics :- 

REST API basically means sending and recieving json data

	- SpringBoot automatically convert a bean into json ( bean means Java Class )
	- SpringBoot also implements @ResponseBody by default thats why we can also directly return String without any view creation
	
	- @RestController, @GetMapping and path variable
	- When we return a new object it automatically converted into @ResponseBody+ JacksonHttpMessageConverters

	So, to generate json and make a website restful we return object bean from Mapping Methods

	- Request is generally managed by DispatcherServlet ( Mapping servlets = dispatcherServlet urls=[/] )
	- DispatcherServletAutoConfiguration manages each url request automatically and map the request with url
	- Bean converted into json by JacksonHttpMessageConvertersConfiguration automatically
		as RestController provied ResponseBody to each mapping methods and JackHttpMessageConverters convert object into json

	- Error mapping is managed by ErrorMvcAutoConfiguration 

	- All these jars or dependency is managed by SpringBootAutoConfiguration and starter-web contains all spring-webmvc, tomcat-server, spring-web, starter-json
	
	
Path Parameters - 
	
	/users/{id} -> is a path where id is variable which means /users/1 or /users/101
	i.e., {id} is a path parameter

	e.g.,
	@PathVariable annotation used in parameter of RequestMapping method
	

	@GetMapping(path = "/user/path/{name}")
	public HelloWorld helloWorld( @PathVariable String name ) {
		return new HelloWorld( String.format( "Hi, %s!", name ) );
	}



	Path parameter is variable value in a url and it is important for query string


GET Request - Retrieve details of a resource from server
POST Request - Create a new resource
PUT Request - Update an existing resource
PATCH Request - Update a part of a resource
DELETE Request - Delete a resouurce



Spring Boot Simple Social Media Application :-

Users - id, name, birthDate
Posts - id, description

Users REST API
	- GET /users
	- POST /users
	- GET /users/{id}
	- DELETE /users/{id}
	
	- Posts REST API
		- GET /users/{id}/posts
		- POST /users/{id}/posts
		- GET /users/{id}/posts/{post_id}
		- DELETE /users/{id}/posts/{post_id}


To recieve an object from POST mapping on REST API
 we need to use @RequestBody annotation 
In addition to this, we also need an API Extension in browser to send post request(Talend API)
	e.g., 
		we can send as well recieve json from url
	@PostMapping(path = "/users")
    	public void createUser(@RequestBody User user) {
        	service.save(user);
    	}

	recieve a json and convert it into object and perform the operation


DAO means data access operations


ALWAYS Execute urls and watch out response status and manage the exception with right response status

Response Status for REST API =>
	Resource not found 404
	Server Exception 500
	Validation Error 400
	
	Success 200
	Response Created 201
	No Content 204
	Unauthorized 401
	
We must return response status correctly with currect location header that is URI,
	@PostMapping(path = "/users")
    	public ResponseEntity<User> createUser(@RequestBody User user) {
        	User savedUser = service.save(user);

		URI location = ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}").buildAndExpand(savedUser.getId()).toUri();
		return ResponseEntity.created(location).build();
    	}

	- ServletUriComponentsBuilder to create new uri
	- ResponseEntity to return the uri as response

For Resource Not Found we need to throw an error saying not found and Response Status as 404

for that we need to create a class 
@ResponseStatus(code = HttpStatus.NOT_FOUND)
public class UserNotFoundException extends RuntimeException {

    public UserNotFoundException(String message) {
        super(message);
    }
}

and 
@GetMapping(path = "/users/{id}")
    public User retrieveOneUser(@PathVariable Integer id) {
        User user = service.findOne(id); 
        if(user == null) throw new UserNotFoundException("Not Found");

        return user;
    } 


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//@ResponseStatus(code = HttpStatus.NOT_FOUND)
//We use above annotation to print correct response status
//We need not use this annotation when we generate ResponseEntity using ResponseEntityExceptionHandler
// because we return ResponseEntity with ResponseStatus and ResponseBody
// i.e., return new ResponseEntity<>(errorDetails, HttpStatus.NOT_FOUND);
public class UserNotFoundException extends RuntimeException{

    public UserNotFoundException(String message) {
        super(message);
    }
}





_____________________________________________________________________________________________________________________________________________________________---



We need to manage Response Status and Response body for exceptions for that purpose we use @ControllerAdvice class by extending RsponseEntityExceptionHandler.
And using methods for different Exception class files using @ExceptionHandler(<some-exception-class>.class) annotation

we return ResponseEntity<> type from method 

e.g.,

public class ErrorDetails {

    private LocalDateTime timestamp;
    private String message;
    private String description;

    public LocalDateTime getLocalDateTime() {
        return timestamp;
    }

    public String getMessage() {
        return message;
    }

    public String getDescription() {
        return description;
    }

    public ErrorDetails(LocalDateTime localDateTime, String message, String description) {
        super();
        this.timestamp = localDateTime;
        this.message = message;
        this.description = description;
    }

}


AND

@ControllerAdvice
public class CustomizeResponseEntityExceptionHandler extends ResponseEntityExceptionHandler {
    
    @ExceptionHandler(Exception.class) //Used for all exception 
    public ResponseEntity<ErrorDetails> handleAllException(Exception ex, WebRequest request) {
        ErrorDetails errorDetails = new ErrorDetails(LocalDateTime.now(), ex.getMessage(), request.getDescription(false));

        return new ResponseEntity<ErrorDetails>(errorDetails, HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @ExceptionHandler(UserNotFoundException.class) // used for self throw exception
    public ResponseEntity<ErrorDetails> handleUserNotFoundException(Exception ex, WebRequest request) {
        ErrorDetails errorDetails = new ErrorDetails(LocalDateTime.now(), ex.getMessage(), request.getDescription(false));

        return new ResponseEntity<ErrorDetails>(errorDetails, HttpStatus.NOT_FOUND);
    }
}



We have different methods that we can override from ResponseEntityExceptionHandler for custom Response Body and Response Status

In Validation these overriding of methods so much great for generating exception for validation e.g., Bad Request etc.

e.g., 

    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {
        ErrorDetails errorDetails = new ErrorDetails(LocalDateTime.now(), ex.getLocalizedMessage(), request.getDescription(false));
        return new ResponseEntity<>(errorDetails, HttpStatus.BAD_REQUEST);
    }


Take help of oogle to find methods for each exceptions...

@Size(min=2, message="At least 2 characters")
private String name;

when validation failed call above overriden method



++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Generating Documentation - Swagger UI and Open API
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

we need to add dependency to implement open api and ui for documentation of our whole REST API

org.springdoc:springdoc-openapi-starter-webmvc-ui

After  running our REST API we can see our documentation in raw form by visiting http://localhost:8080/v3/api-docs  [open api give the raw output]
and in graphical form by visiting http://localhost:8080/swagger-ui.html   [ swagger ui give graphical output ]


______________________________________________________________________________________________________________________________________________________________________________________


+++++++++++++++++++++++++++++++++++++++++++++++++++
Content Negotiation =>
++++++++++++++++++++++++++++++++++++++++++++++++++


Used to generate response in different forms by default we get json format response  but we can also change  response in different format such as xml
also language of content ie., english, french, etc.

Consumer tell the rest api which form they want the data to be recieved by Accept Header specifying MIME types that is application/json or application/xml etc.
or by Accept-Language header (en, nl, fr etc.)


For content negotitation we need to add dependency- com.fasterxml.jackson.dataformat:jackson-dataformat-xml

Now whenever a user made a request with application/xml Accept Header, our REST API automatically generate response in xml format instead of json which is default


INTERNATIONALIZATION :- i18n
 User send request with Accept-Language header with en/nl/fr , response generated automatically in that language.

@Autowired private MessageSource messageSource;

@GetMapping(path = "hello-world")
public String helloWorld() {
	Locale locale = LocaleContextHolder.getLocale();
	return messageSource.getMessage("good.morning.message", null, "Default Message lets say Good MRNG", locale);
}

AND in src/resource we need to create messages.properties, messages_nl.properties, messages_fr.properties
in these file we declare a property that is good.morning.message=Good Morning, good.morning.message=Goedomorgen, good.morning.message=Bonjour respectively.


[So, messages.properties, LocaleContextHolder.getLocale(), MessageSource getMessage()]




--------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------

Versioning REST API -  We use versioning if we have to implement new feature without affecting previous UI functionality
So we can have different way to implement same thing without making user inconvient to new functions directly
--------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------

Implemented using versioning URL(Twitter), Request Params(Amazon), Header(Microsoft), Media type(Github)

URL -

i.e., localhost:8080/v1/user and localhost:8080/v2/user

public class Name {

    private String firstName;
    private String lastName;
    public Name(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    @Override
    public String toString() {
        return "Name{" +
                "firstName='" + firstName + '\'' +
                ", lastName='" + lastName + '\'' +
                '}';
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }
}


	
public class HelloWorld2 {

    private Name name;

    public Name getName() {
        return name;
    }

    public void setName(Name name) {
        this.name = name;
    }

    public HelloWorld2(Name name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "HelloWorld2{" +
                "name=" + name +
                '}';
    }
}


public class HelloWorld {
    private String message;

    public HelloWorld(String message) {
        this.message = message;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    @Override
    public String toString() {
        return "HelloWorld{" +
                "message='" + message + '\'' +
                '}';
    }
}



    @GetMapping(path = "/v1/hello")
    public HelloWorld helloVersionOneWorld() {
        return new HelloWorld("Bob Builder");
    }

    @GetMapping(path = "/v2/hello")
    public HelloWorld2 helloVersionTwoWorld() {
        return new HelloWorld2( new Name("Ram", "Prasad") );
    }


Request Parameters -

i.e., localhost:8080/user?version=1 and localhost:8080/user?version=2

    @GetMapping(path = "/hello", params = "version=1")
    public HelloWorld helloVersionOneWorld() {
        return new HelloWorld("Bob Builder");
    }

    @GetMapping(path = "/hello", params = "version=2")
    public HelloWorld2 helloVersionTwoWorld() {
        return new HelloWorld2( new Name("Ram", "Prasad") );
    }

Header Versioning -
	i.e., localhost:8080/hello/header and Header is X-API-Custom-Header : 1 or X-API-Custom-Header : 2

    @GetMapping(path = "/hello/header", headers = "X-API-Custom-Header=1")
    public HelloWorld helloVersionOneWorld() {
        return new HelloWorld("Bob Builder");
    }

    @GetMapping(path = "/hello/header", headers = "X-API-Custom-Header=2")
    public HelloWorld2 helloVersionTwoWorld() {
        return new HelloWorld2( new Name("Ram", "Prasad") );
    }


Media Type Versioning -
 aka Content Negotiation or Accept Header

i.e., localhost:8080/hello/accept and Header is Accept : application/vnd.company.app-v1+json or Accept : vnd.company.app-v2+json

    @GetMapping(path = "/hello/accept", produces = "application/vnd.company.app-v1+json")
    public HelloWorld helloVersionOneWorld() {
        return new HelloWorld("Bob Builder");
    }

    @GetMapping(path = "/hello/accept", produces = "application/vnd.company.app-v2+json")
    public HelloWorld2 helloVersionTwoWorld() {
        return new HelloWorld2( new Name("Ram", "Prasad") );
    }




Choose any one versioning before starting any project 


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


Json HAL ( Hypertext Application Language )

Used to send links with data in response body 
Adding link in response body is difficult to manage by ourselves when we use custom format and implementation using beans
e.g., 
{
	"name": "weki",
	"_links": {
		"all-users": {
			"href" : "http://localhost:8080/users"
		}
	}
}


We use standard implementation that is HAL using Spring Hateoas 
Spring HATEOAS generate HAL responses with links to resources

Dependency - org.springframework.boot:spring-boot-starter-hateoas


We implement hal logic in controller bean by implementing some imports

import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.*;


    @GetMapping(path = "/users/{id}")
    public EntityModel<User> retrieveOneUser(@PathVariable Integer id) {
        User user = service.findOne(id); 
        if(user == null) throw new UserNotFoundException("Not Found");

	  EntityModel<User> entityModel = EntityModel.of(user);
        WebMvcLinkBuilder link = linkTo( methodOn( this.getClass() ).retrieveAllUser() ); // generate link to retrieveAllUser method
	  entityModel.add( link.withRel( "all-user" ) );

        return entityModel;
    } 


We use HAL explorer to explore all hal responses and links in graphical format and we can interact with links too.

Dependency - org.springframework.data:spring-data-rest-hal-explorer

mapped to "/" => localhost:8080/



++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Filtering - generating responses such that it display specific values and keys
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Serialization - convert object to stream e.g., json or xml

most popular json serialization is Jackson

1.@JsonIgnore and @JsonIgnoreProperties generate same json response for every bean
 (Static Filtering)


public class HelloWorld {

    @JsonIgnore
    private String message;

	@JsonProperty("my_age") //used to show "my_age" : "18" in response for "age" attribute
    private String age;
    private String detail;
}
 or 

@JsonIgnoreProperties( {"message", "detail"} )
public class HelloWorld {
    private String message;
    private String age;
    private String detail;
}

2. Using @JsonFilter with FilterProvider - used for generating different response body for different beans
 (Dynamic Filtering)

@JsonFilter
public class HelloWorld {
    private String message;
    private String age;
    private String detail;
}


@GetMapping("/filtering")
public MappingJacksonValue filtering() {
	SomeBean someBean = new SomeBean("value1", "value2", "value3");
	
	MappingJacksonValue mappingJacksonValue = new MappingJacksonValue(someBean);

	SimpleBeanPropertyFilter filter = SimpleBeanPropertyFilter.filterOutAllExcept( "field1", "field3" );  // field1 and field3 is attributes of SomeBeanFilter class bean
	FilterProvider filters = new SimpleFilterProvider().addFilter( "SomeBeanFilter", filter); //SomeBeanFilter is class bean

	mappingJacksonVakkue.setFilters( filters );

	return mappingJacksonValue;
}
//above filter generate response with filed1 and field3



@GetMapping("/filtering-list")
public MappingJacksonValue filtering() {
	List<SomeBean> list = Arrays.asList( new SomeBean("value1", "value2", "value3"), new SomeBean("value4", "value5", "value6") );
	
	MappingJacksonValue mappingJacksonValue = new MappingJacksonValue( list );

	SimpleBeanPropertyFilter filter = SimpleBeanPropertyFilter.filterOutAllExcept( "field2", "field3" );  // field2 and field3 is attributes of SomeBeanFilter class bean
	FilterProvider filters = new SimpleFilterProvider().addFilter( "SomeBeanFilter", filter); //SomeBeanFilter is class bean

	mappingJacksonVakkue.setFilters( filters );

	return mappingJacksonValue;
}
//above filter generate response with filed2 and field3



Now /filtering and /filtering-list will generate different response body based on filters



+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


Making a relation between two tables say entities 

e.g., 
@Entity(name = "user1")
public class User {

    @Id
    @GeneratedValue
    public Integer id;

    @Size(min = 2, message = "Must contain at least 2 characters")
    public String name;
    @Past(message = "Date must be in past")
    public LocalDate dateBirth;

    @OneToMany(mappedBy = "user")
    @JsonIgnore
    private List<Post> posts;

    public User() {}
.
.
.
}


@Entity
public class Post {

    @Id @GeneratedValue
    private Integer id;
    private String description;

    @ManyToOne(fetch = FetchType.LAZY)
    private User user;
    protected Post() {}
.
.
.
}


now table of user1 [id, birth_date, name]
    table of post [id, description, user_id]




    @GetMapping(path = "/users/{id}/posts")
    public List<Post> showUserPosts(@PathVariable Integer id) {
        Optional<User> user = repository.findById(id);
        if(user.isEmpty()) throw new UserNotFoundException("Page Not Found");

        return user.get().getPosts();
    }

	// we have getPost() getter in User class for retrieving List of posts for that user
	// similarly we have setPost for creating a post

    @PostMapping(path = "/users/{id}/posts")
    public ResponseEntity<Post> createUserPost(@PathVariable Integer id, @Valid @RequestBody Post post) {
        Optional<User> user = repository.findById(id);
        if(user.isEmpty()) throw new UserNotFoundException("Page Not Found");

        post.setUser(user.get());
        Post savedPost = postRepository.save(post);

        URI location = ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}").buildAndExpand(savedPost.getId()).toUri();
        return ResponseEntity.created(location).build();
    }

	// we have getUser() getter in Post class for retrieving a User
	// similarly we have setUser for setting a user

	
    @GetMapping(path = "/users/{id}/posts/{post_id}")
    public Post showOneUserPost(@PathVariable Integer id, @PathVariable Integer post_id) {
        Optional<User> user = repository.findById(id);
        if(user.isEmpty()) throw new UserNotFoundException("User Not Found");

       Post post = postRepository.findById(post_id).orElse(null);
       if(post == null) throw new UserNotFoundException("Post Not Found");

       return post;
    }

    @DeleteMapping(path = "/users/{id}/posts/{post_id}")
    public void deleteUserPost(@PathVariable Integer id, @PathVariable Integer post_id) {
        Optional<User> user = repository.findById(id);
        if(user.isEmpty()) throw new UserNotFoundException("User Not Found");

        Post post = postRepository.findById(post_id).orElse(null);
        if(post == null) throw new UserNotFoundException("Post Not Found");

        postRepository.deleteById(post_id);
    }



+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SPRING SECURITY - for login page 

just add starter-security /login will be added by providing autorisation

By default User Name is user and Password is generated randomly on terminal log screen

we can set our own custom password and username by adding two property in application.properties

spring.security.user.name = root
spring.security.user.password = root


Whenever a request is made searies of filters is performed on the request by Filter Chains

These filters are :-

1.) All requests should be authenticated
2.) If a request is not authenticated, a web page is shown. In rest api we show popup instead of a web page
3.) CSRF -> made POST and PUT fails so we have to diable CSRF

CONFIGURATION for BASIC AUTHENTICATIONS

@Configuration
public class SecurityConfiguration {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        //All request must be authorised
        http.authorizeHttpRequests(auth -> auth.anyRequest().authenticated());

        //a login popup must be shown if not authorized
        http.httpBasic(Customizer.withDefaults());

        //CSRF Disable for POST and PUT requests
        http.csrf().disable();

        return http.build();
    }
}

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


REACT JS



+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



Component based - Single Page Architecture - Only refresh a part of page on request and response

Just like main() in java, in react we have App Component

Parts of Component - 
	- View (JSX or JS)
	- Logic (JS)
	- Styling (CSS)
	- State (Internal Data Source)
	- Props (Pass Data)

React Compponent names must start with Capital letter i.e., must follow PascalCase 
and all html tags must be small case 

We have two ways to create react component -

1. Function Component 

function FirstComponent() {
	return (
		<div className="FirstComponent"> First Component </div>
	)
}

2. Class Component 

import {Component} from './react'

class ThirdComponent extends Component {
	render() {
		return (
			<div className="ThirdComponent"> Third Component </div>
		)
	}
}



Now we just have to add <FirstComponent/> and <ThirdComponent></ThirdComponent> in App Component
Also to use FirstComponent and ThirdComponent we have to import those 

so we have to use export keyword prefixed to function

State - Built-in react object used to contain data or information about a component

NOTE- in earlier version of react only class component can have state and implementing state was very complex

Hooks were introduced in react 16.8
	- Hooks are very easy to use
	- useState hook allows adding state to function component

So, using function component is recommended than class


JSX (JavaScript + XML)

	- React projects uses JSX for presentation
	- Stricter than HTML
		- Close tags are mandatory
		- Only one top level tag allowed 
			i.e., cannot return multiple top level jsx tags
				Wrap into a shared parent tag [  <></> or <div></div>  ]
	- Babel technology is used to convert jsx in to js also babel enables the ability to write older version of JS code by using modern version JSX with latest JS features

	- In JSX, css class is specified by cssClass attribute



JavaScript Object Tutorial

Virtual DOM concept in React

To add a css file to a jsx component
import './location-to/filename.css'


Diffrent Event Handlers like onChange and onClick and different . Take reference on web

useState and useEffect Hook on react documentation

spread operator, destructuring of objects, callback function
map, reduce, filter, find functions

Class component is easy take a look but no need to use 

We write javascript code in jsx in {  }
We can also create an object of CSS and use it in jsx

( Condition && Expression , Ternary Operator for expression)

Must know about Controlled and Uncontrolled Component 
 Form in react js and onSubmit event and event.preventDefault() 


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


 'react-router-dom' -> BrowserRouter, routes, route, useNavigate() [ path and element ]


Manage routes related error that is if no routes are mapped to any component or invalid routes...
	- we create Error Component to handle these errors
e.g., 
	<Route path="*" element={<Error />} />

and

function Error() {
    return (
        <div>
            <h1> We are working really hard.</h1>
            <div>
                <p> Apologies for 404.</p>
            </div>
        </div>
    );
}




useParams() for /welcome/:username where username can be variable
e.g., 
	<Route path="/welcome/:username" element={<Welcome />} />
	navigate(`/welcome/${username}`)
	const { username } = useParams();

	now we can use username in the jsx

TodoList Component :-

                        todos.map(
                                todo => (
                                        <tr key={todo.id}>
                                            <td>{todo.id}</td>
                                            <td>{todo.description}</td>
                                            <td>{todo.targetDate}</td>
                                            <td>{todo.done.toString()}</td>
                                        </tr>
                                )
                        )


    const today = new Date().toDateString()

    const todos = [
        { id: 1, description: 'Learn AWS', done: false, targetDate: today },
        { id: 2, description: 'Learn Kubernetes', done: false, targetDate: today },
        { id: 3, description: 'Learn Azure', done: false, targetDate: today },
        { id: 4, description: 'Learn DevOps', done: false, targetDate: today },
        { id: 5, description: 'Learn SpringBoot', done: false, targetDate: today }
    ]



 To manage href links in jsx ... 

Use react-router-dom component <Link to="" ></Link> instead of <a href=""></a>

because <a> refreshed and load whole page while Link component keeps Single Page Application approach.

<h2> Manage Your Todos ... <a href="/todos">Click Here</a></h2>  to
<h2> Manage Your Todos ... <Link to="/todos">Click Here</Link></h2>



+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

npm install bootstrap 
go to bootstrap node module and copy js and css file for using it in page


add bootstrap to index.js to use throughout the project that is in all components.



Context API - used to provide some values all children or say every component e.g., login success state to every component for better authorization.


createContext and useContext 

we can create a context in which we add some values which can be available any component by using useContext hook.

e.g.,

ContextCreator.js
	const context = createContext({});
	export default context;	

LoginContext.jsx
	import contextCreator from "./ContextCreator";
	export default function LoginContext( props ) {
		//we can also use useState hook here for value
    		return (
       		 <contextCreator.Provider value={ 'WeKi' }>
           		 {props.children}
        		 </contextCreator.Provider>
    		);
	}

//To make the value available to all components we need a parent tag 

in App.js

	<LoginContext>
		<BrowserRouter>
                <Header />

                <Routes>
                    <Route path="/" element={<Login />} />
                    <Route path="/login" element={<Login />} />

                    <Route path="/welcome/:username" element={<Welcome />} />
                    <Route path="/todos" element={<ListTodos />} />

                    <Route path="/logout" element={<Logout />} />
                    <Route path="*" element={<Error />} />
                </Routes>

                <Footer />
            </BrowserRouter>
      </LoginContext>




//To use values of context

    const context = useContext(contextCreator);

    console.log(context)



+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


We can also make custom hook which can return useContext(context)
e.g., 
ContextCreator.js
	const context = createContext({});
	export const useCustomContext = () => useContext(context)
	export default context;	


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



To use authentication on all other components 

    const [isAuthenticated, setAuthenticated] = useState(false)

    return (
        <contextCreator.Provider value={ {isAuthenticated, setAuthenticated} }>
            {props.children}
        </contextCreator.Provider>
    );


now we can use useCustomContext() to make a useAuth variable and using that variable we can set authentication to true or false and also use this boolean value to display 
nav-links in navbar also we can set authentication to false when we click on logout button to hide all other nav-links that is all other components.


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Secure route so no one can access to any route and whenever someone try to go to specific route redirect them to login 


We need a component to check for authenticated routes 

AuthenticatedRoute.jsx
		
			import {useCustomContext} from "./context/ContextCreator";
			import {Navigate} from "react-router-dom";

			export function AuthenticatedRoute( props ) {
    				const useAuth = useCustomContext();
	    			if(useAuth.isAuthenticated) return props.children
    				return <Navigate to='/' />
			}


To make a route authenticated,

	              <Route path="/welcome/:username" element={
                        <AuthenticatedRoute> <Welcome /> </AuthenticatedRoute>
                    } />




+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


Using [ AXIOS ] framework to call rest api using react urls


    const callHelloWorldRestApi = () => {
        //AXIOS for calling REST API
        //npm install axios
        axios.get('http://localhost:8080/hello-world')
            .then( (response) => successfulResponse(response) )
            .catch( (response) => errorResponse(response) )
            .finally( () => console.log("Clean Up ... ") )
    }

    const successfulResponse = (response) => {
        console.log(response)
    }

    const errorResponse = (response) => {
        console.log(response)
    }


	
<button className="btn btn-success m-5 p-3" onClick={callHelloWorldRestApi}>Hello API</button>


 get() => calls the rest api get method
 post(), delete() etc.....
 then() => perform acction based upon rest api data
 catch() => invoked when there is an error while getting json from api
 finally() => invoked each time whether it is success or error mainly used for cleanup purposes 


BY DEFAULT 

Access to XMLHttpRequest at 
'http://localhost:8080/hello-world' from origin 'http://localhost:3000' has been blocked by 
CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.


which means we cannot fetch data from different websites thats why we need to handle cors policy by allowing Access Allow Origin Control Header


we need to authorise Cross Origin Request or CORS confuguration
(WebMvcConfigurer.class)

We need to allow access by creating bean in main class where we override WebMvcConfigurer corsConfigurer() { ... }, addCorsMapping(CorsRegistry corsRegistry) {...}


@SpringBootApplication
public class TodoRestApiApplication {

    public static void main(String[] args) {
        SpringApplication.run(TodoRestApiApplication.class, args);
    }
    
    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/**")
                        .allowedMethods("*")
                        .allowedOrigins("http://localhost:3000");
            }
        };
    }

}

"/**" => allowed for everyone admin, user etc.
"*" => allowed to all methods 


In above bean we provide access to localhost:3000 so that api of localhost:8080 is accessible by localhost:3000
that CORS policy is upgraded according to above code by adding a mapping

also add .requestMatchers(HttpMethod.OPTIONS).permitAll()


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Instead of typing localhost:8080 everytime in

export const retrieveHelloWorldApi = () => axios.get("http://localhost:8080/hello-world-bean");

We Can Use, 
const clientUrl = axios.create(
    {
        baseURL: "http://localhost:8080"
    }
)

export const retrieveHelloWorldApi = () => clientUrl.get("/hello-world-bean");

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

getting all todos for a specific user 
___________________________________________

    const [todos, setTodos] = useState([])

    useEffect( () => getTodosByUsername(), [] )

    const getTodosByUsername = () => {
        retrieveTodos('in28minutes')
            .then( (response) => setTodos(response.data) )
            .catch( (response) => console.log(response) )
    }


Here, useEffect is used whenever we refresh a page based on a given dependency written in []

useEffect( () => getTodosByUsername(), [id] )
it means whenever id changes useEffect will invoke getTodoByUsername method




String to Number conversion just divide "-1" by 1 ( '-1'/1 ) to get -1


Use of Formik (npm install formik)
--------------------------------------------------------------------------------------------------------------



import { useNavigate, useParams } from "react-router-dom"
import { useAuth } from "../Context/AuthContext";
import { useEffect, useState } from "react";
import { createTodoApi, retrieveTodoApi, updateTodoApi } from "../api/apiService";
import { ErrorMessage, Field, Form, Formik } from "formik";


function TodoComponent() {
    const authContext = useAuth()
    const username = authContext.username;

    const { id } = useParams()

    const navigate = useNavigate()

    const [description, setDescripton] = useState('')
    const [targetDate, setTargetDate] = useState('')

    useEffect(
        () => retrieveTodo(),
        // eslint-disable-next-line
        [id]
    )

    const retrieveTodo = () => {    
        if( id/1 !== -1 ) {
            retrieveTodoApi(username, id)
                .then( (response) => {
                    setDescripton(response.data.description)
                    setTargetDate(response.data.targetDate)
                } )
                .catch( (e) => console.log(e) )
        }
    }

    const validate = (values) => {
        let errors = {}

        if(values.description.length < 4) errors.description = 'Must be greater than 3 letters'
        if(values.targetDate === '' || values.targetDate === null)
            errors.targetDate = 'Target date must be provided'

        return errors;
    }

    const onSubmit = (values) => {

        const todo = {
            id: id,
            username: username,
            description: values.description,
            targetDate: values.targetDate,
            done: false
        }

        if( id/1 === -1 ) {
            createTodoApi(username, todo)
                .then( () => navigate('/todos') )
                .catch( e => console.log(e) )
        } else {
            updateTodoApi(username, id, todo)
                .then( () => navigate('/todos') )
                .catch( e => console.log(e) )
        }
    }

    return (
        <div className="container text-center">
            <Formik initialValues={ {description, targetDate} } enableReinitialize={true}
                onSubmit={onSubmit}
                validate={validate} validateOnBlur={false} validateOnChange={false}
            >   
                <Form >

                    <ErrorMessage className="alert alert-warning" component='div' name="description" />
                    <ErrorMessage className="alert alert-warning" component='div' name="targetDate" />

                    <fieldset className="form-group">
                        <label htmlFor="description">Description</label>
                        <Field type="text" name="description" id="description" className="form-control" />
                    </fieldset>
                    <br />
                    <fieldset className="form-group">
                        <label htmlFor="targetDate">Target Date</label>
                        <Field type="date" name="targetDate" id="targetDate" className="form-control" />
                    </fieldset>
                    <br />

                   <button type="submit" className="btn btn-success m-5 py-2 px-5 fw-bold"> 
                        Save
                    </button>

                </Form>      
            </Formik>
        </div>
    )
}

export { TodoComponent }



api used  ->
const updateTodoApi = (username, id, todo) => clientUrl.put(`/users/${username}/todos/${id}`, todo)


const createTodoApi = (username, todo) => clientUrl.post(`/users/${username}/todos`, todo)


Add Button -> navigate('/todos/-1')
Update Button -> navigate(`/todos/${id}`)


_____________________________________________________________________________________________________________________________________________________
_____________________________________________________________________________________________________________________________________________________


Basic Authentication using Spring Security ( spring-boot-starter-security )
_____________________________________________________________________________________________________________________________________________________

STEP 1 - Used for basic authentication 

in application.properties file - add username and password 
[
spring.security.user.name=weki
spring.security.user.password=root
]

@Configuration
public class BasicSecurityConfiguration {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {

        http.authorizeHttpRequests( auth -> auth.anyRequest().authenticated() ); //provide authentication for all requests
        
	  http.httpBasic( Customizer.withDefaults() ); // a popup login will show if not authorized 401

        return http.build(); // return SecurityFilterChain through which all of above things will be checked 
    }
}


STEP 2 - making session stateless i.e., with request we must have to send credentials to access api, and disabling csrf so that we can access post, delete, put etc... 
beacause only get method is supported when csrf is not disabled


@Configuration
public class BasicSecurityConfiguration {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {

        http.authorizeHttpRequests( auth -> auth.anyRequest().authenticated() ); 
        
	  http.httpBasic( Customizer.withDefaults() ); 

	  http.sessionManagement(
                session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
        );
        http.csrf().disable();

        return http.build(); 
    }
}

Step 3 - Setting up Authentication header in REACTjs so that with request we can send credential for authentication

const headers = { Authorization: "Basic d2VraTpyb290" }

const helloWorldApi = () => clientUrl.get( '/hello-world-bean', { headers }) 


Here, Basic d2VraTpyb290 is the base64 code of {username}:{password} that is weki:root will be converted in base64 as d2VraTpyb290
and we have to set Authorization to "Basic d2VraTpyb290"




Step 4 - Now when we try to access the api after setting authorization we will still get an error saying 

Access to fetch at 'https://localhost:8002/4' from origin 'http://localhost:3000' has been blocked by CORS policy: 
Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource.

To overcome this we need to permit all OPTIONS request 
because first OPTIONS request method is sent then fetching of data happens 
[
HttpMethod.OPTIONS // for OPTIONS request
"/**" -> for all requests
]

	http.authorizeHttpRequests(
                auth -> auth
                        .requestMatchers(HttpMethod.OPTIONS, "/**").permitAll()
                        .anyRequest().authenticated() 
	);


FINALLY WE GET SOMETHING LIKE THIS

@Configuration
public class BasicSecurityConfiguration {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {


	return
            http
                    .authorizeHttpRequests(
                        auth -> auth
                                .requestMatchers( HttpMethod.OPTIONS, "/**" )
                                .permitAll()
                                .anyRequest()
                                .authenticated()
                        )
                    .httpBasic(Customizer.withDefaults())
                    .sessionManagement( session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS) )
                    .csrf()
                    .disable()
                    .build();
    }
}



________________________________________________________________________________________________________________________________________



Instead of using hard coded basic authorization base64 code we can generate base64 code when user click on login button

As login is pressed we first create a token 
then pass it to a a api method which calls a clientUrl with that token as Authorization header 
if request is valid for token then it return a response with a status having 200 ok status

------------------------------------------------------------------------------------------
@RestController
public class BasicAuthCheckController {

    @GetMapping("/basic-auth-check")
    public ResponseEntity<?> checkBasicAuth() {
        return ResponseEntity.ok().build();
    }
}
------------------------------------------------------------------------------------------
LoginContext.jsx [

	login function waits for a response cause response is a type of promise which leades asynchronous behaviour 
	so we use async function with await keyword for promises 
	await waits for a value to be generated when a reponse is generated then it executes rest of code
	
	NOTE - always use try catch while dealing with Promises or say fetcching something from url api

]

    const login = async (username, password) => {

        const token = 'Basic ' + window.btoa(username+':'+password)

        try {

            const response = await basicAuthCheck(token)

            if( response.status === 200 ) {
                setIsAuthenticated(true)
                setUsername(username)
                setToken(token)
                return true
            } else {
                logout()
                return false
            }
            
        } catch (error) {
            logout()
            return false
        }
         
    }

    const logout = () => {
        setIsAuthenticated(false)
        setUsername(null)
        setToken(null)
    }

------------------------------------------------------------------------------------------------
Login.jsx [ gotoWelcomePage called when user click on login button 
	which waits for true or false value to go to welcome page and give access to user
]

    const gotoWelcomePage = async () => {
        if( await authContext.login(username, password) )
            navigate(`/welcome/${username}`)
        setIsAuthorize(false)
    }
-------------------------------------------------------------------------------------------------

To provide authorization token to all requests without passing token to each apiMethods  we can use axios interceptors to add header in request body

		    clientUrl.interceptors.request.use(
                    config => {
                        config.headers.Authorization = token
                        return config
                    }
                )


for example - 

		if( response.status === 200 ) {
                setIsAuthenticated(true)
                setUsername(username)
                setToken(token)
				
		    clientUrl.interceptors.request.use(
                    config => {
                        config.headers.Authorization = token
                        return config
                    }
                )

                return true
            } 




Here, clientUrl is an object which consist of baseUrl for each request call 

clientUrl.js


	import axios from "axios";

	const clientUrl = axios.create(	
	    {
      	  baseURL: 'http://localhost:8080'
	    }
	)

	export {clientUrl}


______________________________________________________________________________________________________________________________________________________
______________________________________________________________________________________________________________________________________________________


NOTE :- Basic Authentication provide base64 coded token which can be easily decrypted 

thats why we use JWT ( JSON Web Token ) it is more secure and used at production level projects.

___________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________



################################################################

              SPRING SECURITY EVERYTHING:--------

#################################################################


----->  Authentication Filter  <---->  Authentication Manager <-----> Authentication Provider  <------> UserDetailsService    <========>    DataBase
        |
	  |
	  |----->  Security Context


NOTE: - no need to worry about authentication provider because spring security provide default provider for security 



Security Filter Chains :-
__________________________


SecurityFilterChain consists of many filters through which an HttpRequest and HttpResponse is gone through 

______________________________________________________
PasswordEncoder
UserDetailService
UserDetails
AuthenticationProvider
AuthenticationManager
SecurityContextHolder & SecurityContext

############################################################################

JWT -

Consist of three part -> 1. Header contain hashing algorithm type, 2. Payload contain data about issuer, subject, expiry date, audience etc., 3. Signature consist of a secret code which we create

Key Encryption Technique -
	1. Symmetric - A key is used to encode and decode the token
	2. Asymmetric - Public key used to encrypt and Private key is used to decrypt

Asymmetric is recommended

STEPS TO CREATE JWT --->

1. Create JWT
	=> User Credential
	=> User Data (Payload)
	=> RSA KEY PAIR

2. Send JWT as part of request header
	=> Authorization Header
	=> Bearer Token
	=> Authorization: Bearer ${JWT_TOKEN}

3. JWT is verified on server
	=> Needs Decoding
	=> RSA Key Pair (Public Key)


__________________________________________________________________________


Maven Dependency - org.springframework.boot:spring-boot-starter-oauth2-resource-server

ENABLE OAUTH2 Resource Server for authentication -->
There is a method named JwtConfigurer jwt() {...} in OAuth2ResourceServerConfigurer.class file
In SecurityConfig - add this in SecurityFilterChain
	i.e.,  
			=> http.oauth2ResourceServer( OAuth2ResourceServerConfigurer::jwt );

_______________________________________________________________________________

Now we need to define a Bean of type JwtDecoder

@Bean
public JwtDecoder jwtDecoder(){ return decoder; }

__________________________________________________________________________________


Now before returning jwtDecoder we need to follow below steps ----->

1. Create Key Pair
	=> using java.security.KeyPairGenerator ( we gonna use this one )
	=> we can also use openssl ( Take a look on Google )

2. Create RSA Key object using Key Pair
	=> com.nimbusds.jose.jwt.RSAKey

3. Create JWKSource ( JSON Web Key source )
	=> create JWKSet ( a new JSON Web Key set ) with the RSA Key
	=> create JWKSource using JWTSet

4. Use RSA Public Key for Decoding
	=> NimbusJwtDecoder.withPublicKey(rsaKey().toRSAPublicKey()).build();

5. Use JWKSource for Encoding
	=> return new NimbusJwtEncoder(jwkSource());

___________________________________________________________________________________

Step 1 - Create Key Pair

@Bean
public KeyPair keyPair() {
try{
	var keyPairGenerator = KeyPairGenerator.getInstance("RSA"); //choosing hashing algorithm
	keyPairGenerator.initialize(2048); //key size setup
	return keyPairGenerator.generateKeyPair();
} catch (Exception ex) {
	throw new RuntimeException(ex);
}
}


Step 2 - Create RSA key Object

@Bean
public RSAKey rsaKey(KeyPair keyPair) {
	
return new RSAKey.Builder((RSAPublicKey)keyPair.getPublic())
		.privateKey(keyPair.getPrivate())
		.keyId(UUID.randomUUID().toString())
		.build();
}

Step 3 - Create JWKSource

@Bean
public JWKSource<SecurityContext> jwkSource(RSAKey rsaKey){
	
	var jwkSet = new JWKSet(rsaKey);
	
	var jwkSource = new JWKSource() {
		@Override
		public List get(JWKSelector jwkSelector, SecurityContext context) throws KeySourceException {
			return jwkSelector.select(jwkSet);
		}
	} 
	
	return jwkSource;

}

OR WE CAN USE LAMBDA FUNCTION

@Bean
public JWKSource<SecurityContext> jwkSource(RSAKey rsaKey){
	var jwkSet = new JWKSet(rsaKey);
	return (jwkSelector, context) -> jwkSelector.select(jwkSet);
}


Step 4 - Create JwtDecoder

@Bean
public JwtDecoder jwtDecoder(RSAKey rsaKey) throws JOSEException { 
	return NimbusJwtDecoder.withPublicKey(rsaKey().toRSAPublicKey()).build(); 
}


_________________________________________________________________________________________________________

Step 5 - Create JwtEncoder

@Bean JwtEncoder jwtEncoder(JWKSource<SecurityContext> jwkSource) {
	return new NimusJwtEncoder(jwkSource);
}

_________________________________________________________________________________________________________


NOW WE WILL CREATE JWT TOKEN Response as we are ready to generate token using basic authentication i.e., username and password 

@RestController
public class JwtAuthenticationResource {

	@PostMapping("/authenticate")
	public Authentication authenticate(Authentication authentication) {
		return authentication; // returns credentials tree including authorities, authenticated, name, principals, details
	}	

}

NOW as we know what will come in authentication object now we can use these info to build token

______________________________________________________________________________________________________________________________


@RestController
public class JwtAuthenticationResource {

	@Autowired private JwtEncoder jwtEncoder;

	@PostMapping("/authenticate")
	public JwtResponse authenticate(Authentication authentication) {

		return new JwtResponse( createToken(authentication) );
	}	

	private String createToken(Authentication authentication){
		var claims = JwtClaimsSet.builder()
				.issuer("self") //we can use any string
				.issuedAt(Instant.now())
				.expiresAt(Instant.now().plusSecond(60*30))
				.subject(authentication.getName()) //return principal
				.claim("scope", createScope(authentication))
				.build();
		JwtEncoderParameters parameters = JwtEncoderParameters.from(claims);
		return jwtEncoder.encode(parameters).getTokenValue();
	}

	private String createScope(Authentication authentication) {
		return authentication.getAuthorities().stream()
						.map(a->a.getAuthority())
						.collect(collectors.joining(" "));
	}

}

record JwtResponse(String token) {}

________________________________________________________________________________________
########################################################################################
----------------------------------------------------------------------------------------
########################################################################################


Logging Logs in SpringBoot using slf4j and logback also by using bson.Document

we need Mongo-Driver Sync dependency
- MongoClient MongoClients.create() MongoCollection MongoDatabse
	
	<dependency>
            <groupId>org.mongodb</groupId>
            <artifactId>mongodb-driver-sync</artifactId>
            <version>4.8.2</version>
       </dependency>


	logback.xml =>

<configuration>
    <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
        <target>System.out</target>
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <appender name="MongoDb" class="com.weki.loggingrestapi.controller.MongoDbAppender"/>

    <root level="info">
        <appender-ref ref="console"/>
        <appender-ref ref="MongoDb"/>
    </root>

    <logger level="debug" name="com.weki.loggingrestapi">
        <appender-ref ref="MongoDb"/>
    </logger>

</configuration>


MongoDbAppender.java =>

public class MongoDbAppender extends UnsynchronizedAppenderBase<ILoggingEvent> {
    private MongoClient mongoClient;
    private MongoCollection<Document> collection;

    @Override
    public void start() {
        super.start();
        mongoClient = MongoClients.create("mongodb://localhost:27017");
        MongoDatabase database = mongoClient.getDatabase("logback");
        collection = database.getCollection("logs");
    }

    @Override
    public void stop() {
        mongoClient.close();
        super.stop();
    }

    @Override
    protected void append(ILoggingEvent eventObject) {
        Document document = new Document();
        document.append("timestamp", new Date(eventObject.getTimeStamp()))
                .append("level", eventObject.getLevel().toString())
                .append("logger", eventObject.getLoggerName())
                .append("message", eventObject.getMessage());
        if(eventObject.hasCallerData()) {
            document.append(
                    "stacktrace",
                    Arrays.toString(eventObject.getCallerData())
            );
        }
        collection.insertOne(document);
    }
}


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
============================================================================================












